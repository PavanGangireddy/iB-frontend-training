# 1.6 Arrow Functions

* With arrow functions, we are able to omit the curly braces and the return statement due to implicit returns
* Example 1:

```javascript
function timesTwo(params) {
  return params * 2
}
timesTwo(4);  // 8

// Using Arrow functions

let timesTwo = params => params * 2
timesTwo(4);  // 8
```

* Example 2:  Variety of syntaxes

```javascript
// If there are no parameters, you can place an empty parentheses before =>

() => 42

// If there is single parameter, parentheses are optional

x => 42  || (x) => 42

// If there are multiple parameters, parentheses is required

(x, y) => 42
```

* Example 3:  Block body

```javascript
// If your function is in a block, 
// you must also use the explicit return statement

const addValues = (x, y) => {
  return x + y
}
```

* Example 4: Object literals

```javascript
x => ({ y: x })

// If you are returning an object literal, 
// it needs to be wrapped in parentheses. 
```

{% hint style="warning" %}
**Harder to debug**

It is important to note that arrow functions are anonymous, which means that they are not named.

When you get an error, you will not be able to trace the name of the function or the exact line number where it occurred.
{% endhint %}

* Example 5:  Arrow functions do not have `this`

If `this` is accessed, it is taken from the outside.

```javascript
// ES6

let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
    this.students.forEach((student) => {
      console.log(this.title + ': ' + student)
    });
  }
};

group.showList();

// Here in forEach, the arrow function is used, 
// so this.title in it is exactly the same as in the outer method showList. 
// That is: group.title.
```

```javascript
// ES5

let group = {
  title: "Our Group",
  students: ["John", "Pete", "Alice"],

  showList() {
    this.students.forEach(function(student) {
      console.log(this.title + ': ' + student)
    });
  }
};

group.showList();

// The error occurs because forEach runs functions with this=undefined 
// by default, so the attempt to access undefined.title is made.

// That doesn’t affect arrow functions, because they just don’t have this.
```



{% hint style="info" %}
_Arrow functions VS bind_

_There’s a subtle difference between an arrow function `=>` and a regular function called with `.bind(this)`:_

* _`.bind(this)` creates a “bound version” of the function._
* _The arrow `=>` doesn’t create any binding. The function simply doesn’t have `this`. The lookup of `this` is made exactly the same way as a regular variable search: in the outer lexical environment._
{% endhint %}

**References**

* [More on this concept](https://medium.freecodecamp.org/learn-es6-the-dope-way-part-ii-arrow-functions-and-the-this-keyword-381ac7a32881) 
* [When and why arrow functions](https://medium.freecodecamp.org/when-and-why-you-should-use-es6-arrow-functions-and-when-you-shouldnt-3d851d7f0b26)
* [Arrow functions have no this](https://javascript.info/arrow-functions#arrow-functions-have-no-this)

