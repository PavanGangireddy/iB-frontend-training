# 1.6 Arrow Functions

* With arrow functions, we are able to omit the curly braces and the return statement due to implicit returns
* Example 1:

```javascript
function timesTwo(params) {
  return params * 2
}
timesTwo(4);  // 8

// Using Arrow functions

let timesTwo = params => params * 2
timesTwo(4);  // 8
```

* Example 2:  Variety of syntaxes

```javascript
// If there are no parameters, you can place an empty parentheses before =>

() => 42

// If there is single parameter, parentheses are optional

x => 42  || (x) => 42

// If there are multiple parameters, parentheses is required

(x, y) => 42
```

* Example 3:  Block body

```javascript
// If your function is in a block, 
// you must also use the explicit return statement

const addValues = (x, y) => {
  return x + y
}
```

* Example 4: Object literals

```javascript
x => ({ y: x })

// If you are returning an object literal, 
// it needs to be wrapped in parentheses. 
```

{% hint style="warning" %}
**Harder to debug**

It is important to note that arrow functions are anonymous, which means that they are not named.

When you get an error, you will not be able to trace the name of the function or the exact line number where it occurred.
{% endhint %}

* Example 5: No more \`bind\`

In classic function expressions, the `this` keyword is bound to different values based on the _context_ in which it is called. With arrow functions however, `this` is _lexically bound_. It means that it uses`this` from the code that contains the arrow function.

```javascript
// ES5

// Problem with out bind(this)

const bunny = {
  context: 'Bunny GrandMother',
  tasks: ['transform', 'eat cake'],
  showTasks: function() {
    console.log("this.context", this.context);
    this.tasks.forEach(function(task) {
      console.log(this.context + " wants to " + task);
    });
  }
};

bunny.showTasks();

// Understand two different ways to provide grandmother context 
// inside showTasks 
```

```javascript
// ES6

const bunny = {
  context: 'Bunny GrandMother',
  tasks: ['transform', 'eat cake'],
  showTasks: function showTasks(){
    console.log("this.context", this.context);
    this.tasks.forEach((task) => {
      console.log(this.context + " wants to " + task);
    });
  }
};

bunny.showTasks();

// Understand how arrow function is solving the problem
// Also observe what happens if we change the showTasks fn to arrow
// syntax 

```

{% hint style="info" %}
_If an expression is the body of an arrow function, you donâ€™t need braces:_

_`toggleDropDown = () => this.props.toggle()`_

_However prettier handles this formatting for us, automatically._
{% endhint %}

* [More on this concept](https://medium.freecodecamp.org/learn-es6-the-dope-way-part-ii-arrow-functions-and-the-this-keyword-381ac7a32881) 
* [When and why arrow functions](https://medium.freecodecamp.org/when-and-why-you-should-use-es6-arrow-functions-and-when-you-shouldnt-3d851d7f0b26)



```javascript
{% exercise %}
Define a variable `x` equal to 10.

{% initial %}
var x =

{% solution %}
var x = 10;

{% validation %}
assert(x == 10);

{% context %}
// This is context code available everywhere
// The user will be able to evaluate `exposedVar`
var exposedVar = 3;
// ... or call `exposedFunction`
function exposedFunction {
    return 3;
}
{% endexercise %}
```

